# Graphics

Today we will learn how to write graphical applications in Python.

We will use library that is not built-in Python (similar to pytest
which we used for testing). So we have to install it first. open 
your virtual environment and then use `pip` - specifically command -
`python -m pip install pyglet`.
It looks like this:


```console
(venv)$ python -m pip install pyglet
Collecting pyglet
  Downloading pyglet-1.2.4-py3-none-any.whl (964kB)
Installing collected packages: pyglet
Successfully installed pyglet-1.2.4
```

If you installed pygled successfully try to run
following program. There should appear
black window.

```python
import pyglet
window = pyglet.window.Window()
pyglet.app.run()
print('Done!')
```

> [note]
> If your window is black but there is some rubbish
> don't mind it now. Before we will start to draw 
> in the window we will clean it.


Done? Let's explain what is exactly happening.


## Interactive programs

Let's have a look how program for 1D tic tac toe looks like.
You can see in the comments what every line of code is
doing.


```python
def tictactoe1d():
    field = '-' * 20                # Game preparation
    while True:                     # Repetition:
        field = player_move(field)  # 1. Ask player about their move
        if evaluate(field) != '-':  # 2. Evaluate move
            break
        print(field)                # 3. Print how game looks like

                                    # And again:
        field = ai_move(field)      # 1. Ask computer about its move
        if evaluate(field) != '-':  # 2. Evaluate move
            break
        print(field)                # 3. Print how game looks like
```

We have two types of actions/events in this program, which alternate regularly.
When action is called, it's then evaluated and printed.

We already had similar structure of reactions, for example:
rock, paper, scissors.

* Some preparation
* Until program finishes
    * Read some input
    * Evaluate the input
    * Print result

And similarly works a lot of different programs which
somehow respond to input or other actions/events.

Web server is waiting for *request* about webpage. When it
gets some, it will proccess for example page that is saved on
disk and as output it sends some response.

More complex programs are responding to a lot
of sorts of actions/events, not only to "request"
or "player move"/"computer move". What happens after
input evaluation depends on type of the action.

Your web browser is waiting for a mouse click or a keystroke
and it will behave by the type of key you press or where you
clicked - maybe it sends request to the remote server.
And then it's waiting for another action. There may come a response from
server and then the web browser renders the page
to the screen. Or the user can press "STOP"
and the request is canceled.

The text editor waits for different input from the keyboard
or mouse and it has to evaluate every input.


So a similar program structure - loop that reads the input, 
processes it and produces output - it is very useful.
It is called *event loop* and programs built on it
are *event-driven*.

When there is something useful for more programs it is
not usuall that each programmer will write it all over from the beginning
but some people write it once, pack it as a *library* and then everytone 
is using it.

## Pyglet üê∑

One of such libraries is Pyglet.
It contains event loop and some functions for
2D graphics(with help of another library - OpenGL)
and also retrieving keyboard and mouse events.

Let's go back to the program that opens a window:

```python
import pyglet
window = pyglet.window.Window()
pyglet.app.run()
print('Done!')
```

The whole event loop is hidden in function `pyglet.app.run()`.
Loading of an input (e.g. from keyboard) is Pyglet doing
itself but evaluation and drawing the result is for each program
different so you will have to program it by yourself. 

Currently Pyglet is proccessing only two events:
closing of the window (by "x" button which is added by 
operating system) and pressing <kbd>Esc</kbd> key,
which also closes the window.
After the window is closed event loop (function `pyglet.app.run()`)
ends and program continues to the next line of code.


## Text

<kbd>Esc</kbd> key is not interesting
so let's have a look on another keys.

In Pyglet when you want respond to some event you have to
write a function and then you *register* it - you tell
Pyglet to call this function in the right time.
Event that happens when user is writing something
on keyboard is called `on_text` in Pyglet and it's
processed this way:

{# XXX - highlight "process_text" and "window.push_handlers" blocks #}
```python
import pyglet
window = pyglet.window.Window()

def process_text(text):
    print(text)

window.push_handlers(on_text=process_text)

pyglet.app.run()
```

What is it doing? `window.push_handlers(on_text=process_text)`
tells Pyglet that when user writes something into our
window Pyglet have to call function `process_text`. This
function gets one argument with what user wrote.

Notice that when we are registering our function
we are __not__ writing brackets although we 
[once]({{ lesson_url('beginners/functions') }}) said
that functions have to be called that way.
Do you remember this example? Maybe you found it wird back then.

```python
from math import sin
print(sin(1))
print(sin)
print(sin + 1)
```

Now when we know apart from numbers, strings, `True/False` also
files, lists, tuples and others we can say that function
in Python is value like every other.
Numbers can be multiplied, strings can be written into a file,
we can read from files and functions are only different by that
that they can be called.
But before we call function we can store the function
into some variable:

```python
write = print
write("Hello world!")
```

or we can pass a function to another function as an argument:

```python
print(print)
```

And function `window.push_handlers` was directly writen to
process a function. Why? Pyglet doesn't need one result
of function `process_text` - it is useless for it.
And we also can't call the function cause we don't have
usefull `text` as an argument.
That's why we give to Pyglet the function itself and it
will be called everytime user press some key.

## Time ‚è≤

Before we move to the real graphics we will have a look
on another type of event.

It's a *clock tick*). That's an event, which is happening
regularly after some time.

Registration of function for ticks is done differently than `on_text`:
Funkce pro tiky se registruje trochu jinak ne≈æ `on_text`:

{# XXX - highlight "tick" and "schedule_interval" blocks #}
```python
import pyglet
window = pyglet.window.Window()

def tick(t):
    print(t)

pyglet.clock.schedule_interval(tick, 1/30)

def process_text(text):
    print(text)

window.push_handlers(on_text=process_text)

pyglet.app.run()
```

What is it doing? `pyglet.clock.schedule_interval(tick, 1/30)`
tells Pyglet that it should cal the function `tick` every
`1/30` of a second.

Function `tick` gets only one argument - 
how much time has elapsed since the last call.
Mostly it is not exactly 1/30 of a second, it's a bit
more. Computer has also another things to do, so it
doesn't get to our program immediately and it also
takes some time for Python to call our function.

> [note]
> And why 1/30 of a second? Because we will
> create animation later. When 30 images per second 
> are replaced in front of our eyes, 
> the brain connects them to create an illusion of smooth motion.
> <br>
> Most of the movies are using only 24 pictures per second and
> realistic 3D game has up to 60.

## Vykreslov√°n√≠ üñå

<img src="{{ static('had.png') }}" alt="" style="display:block;float:right;">

Program, kter√Ω vypisuje na termin√°l spoustu ƒç√≠sel,
nen√≠ asi zas tak zaj√≠mav√Ω.
T√©ma t√©hle str√°nky je ale grafika, tak se zaƒçnƒõme od
termin√°lu odpout√°vat. Pojƒème kreslit.

Najdi si na Internetu nƒõjak√Ω obr√°zek. Ne moc velk√Ω,
tak 3cm, a≈• je kolem nƒõj v na≈°em ƒçern√©m ok√Ωnku dost
m√≠sta, a nejl√©pe ve form√°tu PNG. Zaƒçni t≈ôeba na
[t√©hle str√°nce](https://www.google.cz/search?tbs=ift:png&tbm=isch&q=snake+icon).
Ale nevyb√≠rej obr√°zek, kter√Ω je cel√Ω ƒçern√Ω, proto≈æe by v na≈°em ƒçern√©m oknƒõ
nebyl vidƒõt.
Ulo≈æ si ho do adres√°≈ôe, odkud spou≈°t√≠≈° sv≈Øj pythonn√≠
program. J√° m√°m t≈ôeba obr√°zek hada v souboru `had.png`.

Pak obr√°zek vykresli (pou≈æij jm√©no souboru se sv√Ωm obr√°zkem):

{# XXX: Highlight "obrazek =", "had =", "vykresli", "on_draw=vykresli" blocks #}
{# XXX: Highlight 'had.png' strongly #}
```python
import pyglet
window = pyglet.window.Window()

def tik(t):
    print(t)

pyglet.clock.schedule_interval(tik, 1/30)

def zpracuj_text(text):
    print(text)

obrazek = pyglet.image.load('had.png')
had = pyglet.sprite.Sprite(obrazek)

def vykresli():
    window.clear()
    had.draw()

window.push_handlers(
    on_text=zpracuj_text,
    on_draw=vykresli,
)

pyglet.app.run()
```

Povedlo se?

Vysvƒõtleme si, co se tady dƒõje:

* `obrazek = pyglet.image.load('had.png')` naƒçte ze souboru obr√°zek
* `had = pyglet.sprite.Sprite(obrazek)`
  vytvo≈ô√≠ speci√°ln√≠ objekt [Sprite](https://cs.wikipedia.org/wiki/Sprite_%28po%C4%8D%C3%ADta%C4%8Dov%C3%A1_grafika%29),
  kter√Ω urƒçuje, ≈æe tento obr√°zek chceme ‚Äûposadit‚Äú
  na urƒçit√© m√≠sto v ƒçern√©m ok√Ωnku.
  Kdy≈æ neudƒõl√°me nic dal≈°√≠ho, bude obr√°zek ƒçekat v lev√©m rohu.
* Funkce `vykresli()` se star√° o vykreslen√≠ okna ‚Äì v√Ωstup na≈°eho programu.
  Vol√° se v≈ædycky, kdy≈æ je pot≈ôeba okno p≈ôekreslit ‚Äì
  nap≈ô√≠klad kdy≈æ okno minimalizuje≈° a pak vr√°t√≠≈°
  nebo p≈ôesune≈° ƒç√°steƒçnƒõ ven z obrazovky a pak d√°≈° zase zpƒõt.
  A nebo kdy≈æ budeme nƒõco animovat.

> [note]
> Nƒõkter√© operaƒçn√≠ syst√©my si pamatuj√≠ i obsah oken,
> kter√© nejsou vidƒõt, ale nen√≠ radno na to spol√©hat.

* `window.clear()` vyƒçist√≠ okno ‚Äì nat≈ôe ho ƒçernou barvou a sma≈æe
  v≈°echno, co v nƒõm bylo p≈ôedt√≠m.

> [note]
> Na spoustƒõ poƒç√≠taƒç≈Ø tohle nen√≠ pot≈ôeba.
> Ale je lep≈°√≠ ps√°t programy tak, aby
> bƒõ≈æely spr√°vnƒõ kdekoli.

* `had.draw()` nakresl√≠ obr√°zek pomoc√≠ p≈ôedp≈ôipraven√©ho *spritu* `had`.
* `window.push_handlers(on_draw=vykresli)` zaregistruje funkci `vykresli` ‚Äì
  ≈ôekne Pygletu, aby ji volal v≈ædy, kdy≈æ je t≈ôeba.
  <br>
  Kdy≈æ pot≈ôebuje≈° zaregistrovat pro jedno okno
  v√≠c funkc√≠ na obsluhu ud√°lost√≠,
  daj√≠ se d√°t funkci `push_handlers`
  takhle najednou.

Jak√©koli kreslen√≠ se *mus√≠* dƒõlat v r√°mci kresl√≠c√≠ funkce,
kterou Pyglet vol√° z `on_draw`.
Jinde funkce jako `clear` a `draw` nebudou fungovat spr√°vnƒõ.

## Animace

Pojƒè si teƒè se Spritem trochu pohr√°t.

Do funkce `zpracuj_text` dej m√≠sto printu tento p≈ô√≠kaz:

```python
def zpracuj_text(text):
    had.x = 150
```


N√°≈° Sprite m√° *atribut* (angl. *attribute*)
`x`, kter√Ω urƒçuje jeho <var>x</var>-ovou sou≈ôadnici ‚Äì
jak moc je vpravo od okraje okna.
Tenhle atribut se d√° nastavit, jak bude≈° cht√≠t ‚Äì nejƒçastƒõji
v reakci na nƒõjakou ud√°lost, ale ƒçasto se nastavuje
i na zaƒç√°tku programu.

Zaj√≠mav√© je zkusit k `x` nƒõco p≈ôiƒç√≠st p≈ôi ka≈æd√©m tiknut√≠ hodin.
Dok√°≈æe≈° p≈ôedpovƒõdƒõt, co udƒõl√° tenhle k√≥d?

```python
def tik(t):
    had.x = had.x + t * 20
```


Neboj√≠≈°-li se matematiky, naimportuj `math`
a nech obr√°zek, a≈• se pohybuje podle nƒõjak√© funkce:

```python
def tik(t):
    had.x = had.x + t * 20
    had.y = 20 + 20 * math.sin(had.x / 5)
```


Co se stane, kdy≈æ zaƒçne≈° mƒõnit ta ƒç√≠sla?

Co se stane, kdy≈æ zkus√≠≈° podobnƒõ nastavovat atribut `rotation`?

## Zavolej pozdƒõji

<img src="{{ static('had2.png') }}" alt="" style="display:block;float:right;">

Pyglet um√≠ kromƒõ opakovan√©ho ‚Äûtik√°n√≠‚Äú zavolat funkci
jednor√°zovƒõ, za urƒçitou dobu.

St√°hni si (nebo vytvo≈ô) druh√Ω obr√°zek. J√° m√°m druh√©ho
hada, tentokr√°t s trochu natoƒçenou hlavou a ocasem.

A≈æ bude≈° m√≠t obr√°zek v adres√°≈ôi s programem,
p≈ôidej tƒõsnƒõ p≈ôed `pyglet.app.run()` tenhle kus k√≥du:

{# XXX: Highlight 'had2.png' strongly #}
```python
obrazek2 = pyglet.image.load('had2.png')

def zmen(t):
    had.image = obrazek2

pyglet.clock.schedule_once(zmen, 1)
```

Vol√°n√≠ `schedule_once(zmen, 1)` ≈ô√≠k√° Pygletu,
≈æe za jednu vte≈ôinu m√° zavolat funkci `zmen`.
A funkce zmƒõn√≠ obr√°zek ‚Äì stejnƒõ jako se p≈ôedt√≠m mƒõnily
sou≈ôadnice.

`schedule_once` se d√° volat i v r√°mci obsluhy jin√© ud√°losti. Zkus funkci `zmen`
nahradit t√≠mhle:

```python
def zmen(t):
    had.image = obrazek2
    pyglet.clock.schedule_once(zmen_zpatky, 0.2)

def zmen_zpatky(t):
    had.image = obrazek
    pyglet.clock.schedule_once(zmen, 0.2)
```

## Klik üê≠

Posledn√≠ vƒõc, na kterou se tady nauƒç√≠me reagovat, je klik√°n√≠.
Tƒõsnƒõ p≈ôed `window.push_handlers` napi≈° funkci:

```python
def klik(x, y, tlacitko, mod):
    had.x = x
    had.y = y
```

‚Ä¶ a pak v `push_handlers` ji zaregistruj
pomoc√≠ ≈ô√°dku `on_mouse_press=klik,`.

Co znamen√° kter√Ω argument, to zkus zjistit sama.

> [note] N√°povƒõda
> * Dokud p≈ô√≠kazovou ≈ô√°dku neopust√≠≈° √∫plnƒõ, bude fungovat `print`!
>   Kdykoliv bude≈° cht√≠t zjistit nƒõjakou hodnotu, prostƒõ si ji vypi≈°.
> * Kolik m√° my≈° tlaƒç√≠tek?
> * Jak se projev√≠ <kbd>Shift</kbd>+klik?


## Pokraƒçov√°n√≠ p≈ô√≠≈°tƒõ

Kouk√°m ≈æe k√≥du u≈æ je dnes tak akor√°t na ukonƒçen√≠ lekce:

```python
import math

import pyglet

window = pyglet.window.Window()

def tik(t):
    had.x = had.x + t * 20

pyglet.clock.schedule_interval(tik, 1/30)

def zpracuj_text(text):
    had.x = 150
    had.rotation = had.rotation + 10

obrazek = pyglet.image.load('had.png')
had = pyglet.sprite.Sprite(obrazek, x=10, y=10)

def vykresli():
    window.clear()
    had.draw()

def klik(x, y, tlacitko, mod):
    print(tlacitko, mod)
    had.x = x
    had.y = y

window.push_handlers(
    on_text=zpracuj_text,
    on_draw=vykresli,
    on_mouse_press=klik,
)

obrazek2 = pyglet.image.load('had2.png')

def zmen(t):
    had.image = obrazek2
    pyglet.clock.schedule_once(zmen_zpatky, 0.2)

def zmen_zpatky(t):
    had.image = obrazek
    pyglet.clock.schedule_once(zmen, 0.2)

pyglet.clock.schedule_once(zmen, 0.2)

pyglet.app.run()
```

Se vstupem z kl√°vesnice a my≈°i, ƒçasov√°n√≠m a vykreslov√°n√≠m
Spritu si vystaƒç√≠≈° u leckter√© hry nebo grafick√© aplikace.

A≈æ bude≈° nƒõjakou hru dƒõlat, zkus udr≈æovat
stav aplikace v seznamech a <var>n</var>-tic√≠ch (p≈ô√≠padnƒõ
slovn√≠c√≠ch a t≈ô√≠d√°ch, kter√© se nauƒç√≠me pozdƒõji).
Jedna funkce by mƒõla umƒõt takov√Ω stav vykreslit a
jin√© s n√≠m pak budou manipulovat.
Tyhle dvƒõ sady funkc√≠ m≈Ø≈æe≈° m√≠t i v jin√Ωch souborech,
aby se nezapletly dohromady.

Zaj√≠m√°-li tƒõ toto t√©ma, zkus si zahr√°t p≈ôilo≈æenou hru
[Pong](static/pong.py),
kter√° ukazuje nƒõkter√© dal≈°√≠
mo≈ænosti Pygletu: psan√≠ textu, kreslen√≠ obd√©ln√≠k≈Ø
a obsluhu jednotliv√Ωch kl√°ves (nap≈ô. ≈°ipek).
Na prvn√≠ pohled m≈Ø≈æe jej√≠ k√≥d vypadat slo≈æitƒõ,
ale zkus si k nƒõmu sednout a s pomoc√≠ koment√°≈ô≈Ø ho pochopit.
Kdyby koment√°≈ôe nestaƒçily, jsou k Pongu p≈ôipraven√©
i [podrobn√© materi√°ly]({{ lesson_url('projects/pong') }}).

To, co jsme tu probral{{gnd('i', 'y', both='i')}} a p√°r vƒõc√≠ nav√≠c,
je shrnuto v [tah√°ku na Pyglet](https://pyvec.github.io/cheatsheets/pyglet/pyglet-basics-cs.pdf),
kter√Ω si m≈Ø≈æe≈° st√°hnout a vytisknout.

A chce≈°-li se do Pygletu pono≈ôit hloubƒõji,
existuje pro nƒõj [dokumentace](http://pyglet.readthedocs.org/en/latest/index.html).
Nebude-li ti v n√≠ nƒõco jasn√©, zeptej se!